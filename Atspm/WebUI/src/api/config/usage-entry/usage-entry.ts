/**
 * Generated by orval v7.9.0 ðŸº
 * Do not edit manually.
 * ATSPM Configuration Api
 * ATSPM Configuration with OData, OpenAPI, Swashbuckle, and API versioning.
 * OpenAPI spec version: 1.0
 */
import {
  useMutation,
  useQuery
} from 'react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from 'react-query';

import type {
  GetUsageEntryCountParams,
  GetUsageEntryFromKeyParams,
  GetUsageEntryParams,
  PatchUsageEntryFromKeyParams,
  PostUsageEntryParams,
  PutUsageEntryFromKeyParams,
  UsageEntry
} from '../aTSPMConfigurationApi.schemas';

import { configRequest } from '../../../lib/axios';




export const getUsageEntry = (
    params?: GetUsageEntryParams,
 signal?: AbortSignal
) => {
      
      
      return configRequest<UsageEntry[]>(
      {url: `/UsageEntry`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetUsageEntryQueryKey = (params?: GetUsageEntryParams,) => {
    return [`/UsageEntry`, ...(params ? [params]: [])] as const;
    }

    
export const getGetUsageEntryQueryOptions = <TData = Awaited<ReturnType<typeof getUsageEntry>>, TError = void>(params?: GetUsageEntryParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUsageEntry>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsageEntryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsageEntry>>> = ({ signal }) => getUsageEntry(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUsageEntry>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUsageEntryQueryResult = NonNullable<Awaited<ReturnType<typeof getUsageEntry>>>
export type GetUsageEntryQueryError = void



export function useGetUsageEntry<TData = Awaited<ReturnType<typeof getUsageEntry>>, TError = void>(
 params?: GetUsageEntryParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUsageEntry>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetUsageEntryQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const postUsageEntry = (
    usageEntry: UsageEntry,
    params?: PostUsageEntryParams,
 signal?: AbortSignal
) => {
      
      
      return configRequest<void>(
      {url: `/UsageEntry`, method: 'POST',
      headers: {'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true', },
      data: usageEntry,
        params, signal
    },
      );
    }
  


export const getPostUsageEntryMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postUsageEntry>>, TError,{data: UsageEntry;params?: PostUsageEntryParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postUsageEntry>>, TError,{data: UsageEntry;params?: PostUsageEntryParams}, TContext> => {

const mutationKey = ['postUsageEntry'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postUsageEntry>>, {data: UsageEntry;params?: PostUsageEntryParams}> = (props) => {
          const {data,params} = props ?? {};

          return  postUsageEntry(data,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostUsageEntryMutationResult = NonNullable<Awaited<ReturnType<typeof postUsageEntry>>>
    export type PostUsageEntryMutationBody = UsageEntry
    export type PostUsageEntryMutationError = void

    export const usePostUsageEntry = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postUsageEntry>>, TError,{data: UsageEntry;params?: PostUsageEntryParams}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof postUsageEntry>>,
        TError,
        {data: UsageEntry;params?: PostUsageEntryParams},
        TContext
      > => {

      const mutationOptions = getPostUsageEntryMutationOptions(options);

      return useMutation(mutationOptions );
    }
    export const getUsageEntryCount = (
    params?: GetUsageEntryCountParams,
 signal?: AbortSignal
) => {
      
      
      return configRequest<UsageEntry[]>(
      {url: `/UsageEntry/$count`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetUsageEntryCountQueryKey = (params?: GetUsageEntryCountParams,) => {
    return [`/UsageEntry/$count`, ...(params ? [params]: [])] as const;
    }

    
export const getGetUsageEntryCountQueryOptions = <TData = Awaited<ReturnType<typeof getUsageEntryCount>>, TError = void>(params?: GetUsageEntryCountParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUsageEntryCount>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsageEntryCountQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsageEntryCount>>> = ({ signal }) => getUsageEntryCount(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUsageEntryCount>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUsageEntryCountQueryResult = NonNullable<Awaited<ReturnType<typeof getUsageEntryCount>>>
export type GetUsageEntryCountQueryError = void



export function useGetUsageEntryCount<TData = Awaited<ReturnType<typeof getUsageEntryCount>>, TError = void>(
 params?: GetUsageEntryCountParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUsageEntryCount>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetUsageEntryCountQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getUsageEntryFromKey = (
    key: number,
    params?: GetUsageEntryFromKeyParams,
 signal?: AbortSignal
) => {
      
      
      return configRequest<UsageEntry>(
      {url: `/UsageEntry/${key}`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetUsageEntryFromKeyQueryKey = (key: number,
    params?: GetUsageEntryFromKeyParams,) => {
    return [`/UsageEntry/${key}`, ...(params ? [params]: [])] as const;
    }

    
export const getGetUsageEntryFromKeyQueryOptions = <TData = Awaited<ReturnType<typeof getUsageEntryFromKey>>, TError = void>(key: number,
    params?: GetUsageEntryFromKeyParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUsageEntryFromKey>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsageEntryFromKeyQueryKey(key,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsageEntryFromKey>>> = ({ signal }) => getUsageEntryFromKey(key,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(key), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUsageEntryFromKey>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUsageEntryFromKeyQueryResult = NonNullable<Awaited<ReturnType<typeof getUsageEntryFromKey>>>
export type GetUsageEntryFromKeyQueryError = void



export function useGetUsageEntryFromKey<TData = Awaited<ReturnType<typeof getUsageEntryFromKey>>, TError = void>(
 key: number,
    params?: GetUsageEntryFromKeyParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUsageEntryFromKey>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetUsageEntryFromKeyQueryOptions(key,params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const putUsageEntryFromKey = (
    key: number,
    usageEntry: UsageEntry,
    params?: PutUsageEntryFromKeyParams,
 ) => {
      
      
      return configRequest<void>(
      {url: `/UsageEntry/${key}`, method: 'PUT',
      headers: {'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true', },
      data: usageEntry,
        params
    },
      );
    }
  


export const getPutUsageEntryFromKeyMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putUsageEntryFromKey>>, TError,{key: number;data: UsageEntry;params?: PutUsageEntryFromKeyParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof putUsageEntryFromKey>>, TError,{key: number;data: UsageEntry;params?: PutUsageEntryFromKeyParams}, TContext> => {

const mutationKey = ['putUsageEntryFromKey'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putUsageEntryFromKey>>, {key: number;data: UsageEntry;params?: PutUsageEntryFromKeyParams}> = (props) => {
          const {key,data,params} = props ?? {};

          return  putUsageEntryFromKey(key,data,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutUsageEntryFromKeyMutationResult = NonNullable<Awaited<ReturnType<typeof putUsageEntryFromKey>>>
    export type PutUsageEntryFromKeyMutationBody = UsageEntry
    export type PutUsageEntryFromKeyMutationError = void

    export const usePutUsageEntryFromKey = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putUsageEntryFromKey>>, TError,{key: number;data: UsageEntry;params?: PutUsageEntryFromKeyParams}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof putUsageEntryFromKey>>,
        TError,
        {key: number;data: UsageEntry;params?: PutUsageEntryFromKeyParams},
        TContext
      > => {

      const mutationOptions = getPutUsageEntryFromKeyMutationOptions(options);

      return useMutation(mutationOptions );
    }
    export const patchUsageEntryFromKey = (
    key: number,
    usageEntry: UsageEntry,
    params?: PatchUsageEntryFromKeyParams,
 ) => {
      
      
      return configRequest<void>(
      {url: `/UsageEntry/${key}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true', },
      data: usageEntry,
        params
    },
      );
    }
  


export const getPatchUsageEntryFromKeyMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchUsageEntryFromKey>>, TError,{key: number;data: UsageEntry;params?: PatchUsageEntryFromKeyParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof patchUsageEntryFromKey>>, TError,{key: number;data: UsageEntry;params?: PatchUsageEntryFromKeyParams}, TContext> => {

const mutationKey = ['patchUsageEntryFromKey'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchUsageEntryFromKey>>, {key: number;data: UsageEntry;params?: PatchUsageEntryFromKeyParams}> = (props) => {
          const {key,data,params} = props ?? {};

          return  patchUsageEntryFromKey(key,data,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchUsageEntryFromKeyMutationResult = NonNullable<Awaited<ReturnType<typeof patchUsageEntryFromKey>>>
    export type PatchUsageEntryFromKeyMutationBody = UsageEntry
    export type PatchUsageEntryFromKeyMutationError = void

    export const usePatchUsageEntryFromKey = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchUsageEntryFromKey>>, TError,{key: number;data: UsageEntry;params?: PatchUsageEntryFromKeyParams}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof patchUsageEntryFromKey>>,
        TError,
        {key: number;data: UsageEntry;params?: PatchUsageEntryFromKeyParams},
        TContext
      > => {

      const mutationOptions = getPatchUsageEntryFromKeyMutationOptions(options);

      return useMutation(mutationOptions );
    }
    export const deleteUsageEntryFromKey = (
    key: number,
 ) => {
      
      
      return configRequest<void>(
      {url: `/UsageEntry/${key}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteUsageEntryFromKeyMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUsageEntryFromKey>>, TError,{key: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteUsageEntryFromKey>>, TError,{key: number}, TContext> => {

const mutationKey = ['deleteUsageEntryFromKey'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUsageEntryFromKey>>, {key: number}> = (props) => {
          const {key} = props ?? {};

          return  deleteUsageEntryFromKey(key,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUsageEntryFromKeyMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUsageEntryFromKey>>>
    
    export type DeleteUsageEntryFromKeyMutationError = void

    export const useDeleteUsageEntryFromKey = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUsageEntryFromKey>>, TError,{key: number}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteUsageEntryFromKey>>,
        TError,
        {key: number},
        TContext
      > => {

      const mutationOptions = getDeleteUsageEntryFromKeyMutationOptions(options);

      return useMutation(mutationOptions );
    }
    